"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[1138],{5943:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>a,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Processes/authentication","title":"Authentication","description":"The purpose of authentication is to verify the identity of a user.  In","source":"@site/docs/Processes/authentication.md","sourceDirName":"Processes","slug":"/Processes/authentication","permalink":"/open-pocket-docs/docs/Processes/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/abdulrahim2002/open-pocket-backend-server/tree/docs/docs/Processes/authentication.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Authentication","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Processes","permalink":"/open-pocket-docs/docs/category/processes"},"next":{"title":"add request lifecycle","permalink":"/open-pocket-docs/docs/Processes/add_request_lifecycle"}}');var i=s(4848),t=s(8453);const o={title:"Authentication",sidebar_position:1},d="Authentication Overview",l={},c=[{value:"Registration",id:"registration",level:2},{value:"Login",id:"login",level:2},{value:"Refresh",id:"refresh",level:2},{value:"Userful links",id:"userful-links",level:2},{value:"TODOs",id:"todos",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"authentication-overview",children:"Authentication Overview"})}),"\n",(0,i.jsxs)(n.p,{children:["The purpose of authentication is to verify the identity of a user.  In\nour application, resources are primarily owned by ",(0,i.jsx)(n.code,{children:"email addresses"}),". If\na user is successfully able to claim an email by providing correct\npassword. Then he/she can get unvetted access to all resources belonging\nto that email address."]}),"\n",(0,i.jsx)(n.h2,{id:"registration",children:"Registration"}),"\n",(0,i.jsxs)(n.p,{children:["Registration is the simple process of inserting a new user into the\nsystem. In ",(0,i.jsx)(n.code,{children:"open-pocket"}),", the registration follows this simple\nprocedure:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["user makes a POST request to ",(0,i.jsx)(n.code,{children:"/register"})," endpoint with name, email,\npassword. See example request below:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'POST /register\n\n{\n    "name": "test name",\n    "email": "test@example.com",\n    "password": "userpassworod"\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["On receiving this request, the server:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"tries to insert the user into postgres database"}),"\n",(0,i.jsx)(n.li,{children:"if no error occurs, a (201) CREATED response is sent"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"If the user already exists in the system, the above insert fails, and\nserver responds with (409) CONFLICT. Ensuring that no duplicate\nrecords are inserted"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"login",children:"Login"}),"\n",(0,i.jsxs)(n.p,{children:["At the ",(0,i.jsx)(n.code,{children:"/login"})," endpoint, the user tries to proof, that they are the\nowner of a particular email address. This can be done by 2 methods."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["providing ",(0,i.jsx)(n.code,{children:"email"}),", ",(0,i.jsx)(n.code,{children:"password"})," in request body"]}),"\n",(0,i.jsxs)(n.li,{children:["you are already authorized because the server setted up an encrypted\ncookie saying ",(0,i.jsx)(n.code,{children:"authenticated=true"})]}),"\n",(0,i.jsx)(n.li,{children:'providing an authentication token in "Authorization" header'}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The primary method of authentication is through providing an ",(0,i.jsx)(n.code,{children:"email"})," and\n",(0,i.jsx)(n.code,{children:"password"}),". See below for an example request:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'POST /login\n\n{\n    "email": "test@example.com",\n    "password": "testpassword"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Upon receiving the request. The server does the following:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["try to retrieve the user from the database","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"if user is not present or an error occurs -> return failure"}),"\n",(0,i.jsx)(n.li,{children:"note the hashed password of the given user"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["hash the password supplied in request and compare it with the\npassword_hash stored in the database","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"if they do not match -> return failure"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["the server sets an encrypted cookie (also called secure session),\nhaving the following information:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["authenticated=true and ",(0,i.jsx)(n.code,{children:"{ user_id }"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["the server then generates a jwt token and a refresh token","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["the jwt token is created using ",(0,i.jsx)(n.code,{children:"jwt.sign()"})," method"]}),"\n",(0,i.jsxs)(n.li,{children:["the refresh token is created using ",(0,i.jsx)(n.code,{children:"crypto.randomBytes()"})]}),"\n",(0,i.jsxs)(n.li,{children:["in a server side key value store. It sets: ",(0,i.jsx)(n.code,{children:"map[refresh_token] = {user_id}"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The previously generated refresh token (if any) is deleted using:\n",(0,i.jsx)(n.code,{children:"user_refToken_map[user_id] -> (refresh_token)"}),". Then\n",(0,i.jsx)(n.code,{children:"delete map[refresh_token]"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"both jwt token and refresh tokens are send back"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"refresh",children:"Refresh"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"/refresh"})," endpoint is responsible for generating a new set of\n",(0,i.jsx)(n.code,{children:"(access_token, refresh_token)"})," using the old refresh token. Below is an\nexample request:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'POST /refresh\n\n{\n    "refresh_token": "6b2d08fc152adbb12949ba67f9d8ebc579b4dfffd75b79c2b8f9d18cf12929fd"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The server does the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["check if:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"map[supplied_refresh_token] -> returns a { user_id }"})}),"\n",(0,i.jsx)(n.li,{children:"if not return unauthorized"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["else, generate a new pair of jwt token and refresh token, using\n",(0,i.jsx)(n.code,{children:"jwt.sign()"})," and ",(0,i.jsx)(n.code,{children:"crypto.randomBytes()"})," respectively."]}),"\n",(0,i.jsxs)(n.li,{children:["delete the old token using ",(0,i.jsx)(n.code,{children:"delete map[supplied_refresh_token]"})]}),"\n",(0,i.jsxs)(n.li,{children:["add new refresh token using: ",(0,i.jsx)(n.code,{children:"map[refresh_token] = { user_id }"})]}),"\n",(0,i.jsx)(n.li,{children:"return the generated jwt token and refresh token"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"userful-links",children:"Userful links"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.codingshuttle.com/spring-boot-handbook/jwt-refresh-token-and-access-token/",children:"refresh token and access token(jwt)"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc6749#section-1.5",children:"IETF RFC 6749"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc6750",children:"IETF RFC 6759"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html",children:"Authentication best practices"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"todos",children:"TODOs"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"refresh tokens should also have an expiration date"}),"\n",(0,i.jsx)(n.li,{children:"keep the refresh token in a secure unencrypted cookie. For example a\nsimple cookie with (secure=true, httponly, samesite=lax)"}),"\n",(0,i.jsxs)(n.li,{children:["what about the ",(0,i.jsx)(n.code,{children:"/logout"})," endpoint"]}),"\n",(0,i.jsxs)(n.li,{children:["we should also ask for the ",(0,i.jsx)(n.code,{children:"user_id/email"})," in ",(0,i.jsx)(n.code,{children:"/refresh"})," endpoint.\nhence, requiring the client to tell which user are they claiming.\nWithout this, an attacker might try to brute for all possible tokens\nand end up with user data of some users."]}),"\n",(0,i.jsx)(n.li,{children:"rate limit the endpoint (very imp.)"}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);